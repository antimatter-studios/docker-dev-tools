#!/usr/bin/env bash

[ -z "${LC_ALL}" ] && export -p LC_ALL=C
[ -z "${TOOL_PARENT}" ] && export -p TOOL_PARENT=${SHLVL}

function is_parent_script ()
{
  [ "${TOOL_PARENT}" = "${SHLVL}" ] && echo "yes" || echo "no"
}

function is_child_script ()
{
  [ "${TOOL_PARENT}" = "${SHLVL}" ] && echo "no" || echo "yes"
}

function this_dir ()
{
  local b=(${BASH_SOURCE[@]})

  [ "${#b[@]}" -gt 0 ] && b=("${b[@]:1}")

  echo $(tool_realpath $(dirname "${b}"))
}

function this_script ()
{
  local b=(${BASH_SOURCE[@]})

  [ "${#b[@]}" -gt 0 ] && b=("${b[@]:1}")

  echo $(basename "${b}")
}

function this_script_title ()
{
    title=$(this_script)
}

function read_config ()
{
  [ -f "$1" ] && source $1 || tool_fatal_error "There was no /tools/.env file, you must copy the '.env.dist' file to '.env'"
}

function tool_start ()
{
    if [ "$(is_parent_script)" = "yes" ]; then
        [ -z "$1" ] && text red "You must provide a title to this function"

        title=$(text blu $1)
        subtitle=$(text yel $2)

        [ -z "$2" ] && text "${title}" || text "${title}: ${subtitle}"
    fi
}

function tool_fatal_error () {

    [ -z "$1" ] && $1="No error message specified"

    echo -e "${red}$1${end}\n" 1>&2

    # This does not kill process zero, it kills the entire process group (all shells and subshells)
    kill 0
}

function tool_realpath ()
{
    [ -z "$1" ] && tool_fatal_error "tool_realpath: There was no path supplied here, check and try again"

    # the 2>/dev/null here redirects all stderr to the dev null blackhole
    # we do this because on mac realpath is not a valid command, so I have to supress its "command not found" error
    # the || here will then on linux take the first input, but on mac realpath will fail, so it will fallback to the php version
    DIR=$(realpath $1 2>/dev/null || php -r "print realpath('$1');")

    [ ! -e "${DIR}" ] && tool_fatal_error "tool_realpath: The path '${DIR}' calculated from '$1' was not found"

    echo ${DIR}
}

function tool_clone_function ()
{
    local ORIG_FUNC=$(declare -f $1)
    local NEW_FUNC="$2${ORIG_FUNC#$1}"
    eval "$NEW_FUNC"
}

# This command always needs sudo to run one of its subcommands,
# but its really annoying to have to wait 2 minutes before it
# asks you. So I'll put this little sudo command at the top so
# it asks straight away and then it has the permission for a
# small window of time
function grant_early_sudo ()
{
    echo "Early request for sudo access: "
    sudo echo "Sudo access was granted."
}

function get_yn_answer ()
{
    question=$(echo -e $1)

    while true; do
        read -p "$question " yn
        case $yn in
            [YyNn]* ) echo $yn | awk '{print tolower($0)}'; break;;
            * ) echo "Please answer type y or n.";;
        esac
    done
}

function get_http_code ()
{
    curl -s -o /dev/null -I -w "%{http_code}" $1
}

function is_port_open ()
{
    nc -z $1 $2 && echo "yes" || echo "no"
}

function can_ping ()
{
    ping_ok="failure"

    output=$(ping -c 1 -W 1 $1 2>&1)

    name=$(echo ${output} | awk '{if(NR<2)print $2}')
    ip_address=$(echo ${output} | awk '{if(NR<2)print $3}' | sed s:[\(\)\:]::g)
    packet_loss=$(echo ${output} | grep -E -i "(100|100.0)\% packet loss")
    can_resolve=$([ -z "$(echo ${output} | grep -E -i "cannot resolve")" ] && echo yes || echo no)

    [ -z "${name}" ] && name=$1

    [ -z "${packet_loss}" ] && [ "${can_resolve}" = "yes" ] && ping_ok="success"

    [ "${ping_ok}" = "success" ] && message=${ping_ok}
    [ "${ping_ok}" = "failure" ] && message="${ping_ok} ${blu}Can Resolve${end}: ${yel}${can_resolve}${end}"

    text "${yel}Ping '${name}' (${ip_address}) status${end}: ${message}\n"
}

function space_sep_to_csv ()
{
  list=( $@ )
  separator=","
  output="$( printf "${separator}%s" "${list[@]}" )"
  output="${output:${#separator}}" # remove leading separator

  echo ${output}
}

function csv_to_array ()
{
  set -f
  separator=","
  array=(${1//${separator}/ })

  echo ${array[@]}
}

# A little code to set the os_name
export -p os=$(uname | awk '{ print tolower($0) }')
[ "${os}" = "darwin" ] && export -p os_name="Apple Mac OS"
[ "${os}" = "linux" ] && export -p os_name="Linux"

source $(this_dir)/docker
source $(this_dir)/text

# We need to manually export functions like this to make them available to subshells (urgh, fucking bash!!)
export -f this_dir
export -f this_script
export -f tool_fatal_error
export -f tool_realpath
export -f grant_early_sudo
export -f space_sep_to_csv
export -f csv_to_array
