#!/usr/bin/env bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

. ${DIR}/functions/common

ddt_app_start \
    "DDT DOCKER COMPOSE PROXY" \
    "Reverse proxy for all docker compose applications"

docker_image="christhomas/nginx-proxy:alpine"
network_name="ddt_proxy"
name="ddt-proxy"

function help ()
{
    text "${blu}DDT Proxy:${end} (club bouncer says) if your names not down, you're not coming in"
    text "${yel}Usage:${end} ddt-proxy --start"
    text "Options:"
    text "    --start: Run the Nginx proxy"
    text "    --stop: Stop the Nginx proxy"
    text "    --restart: Does a restart (just --stop && --start after each other)"
    text "    --config: Output the raw /etc/nginx/conf.d/default.conf which is generated when containers start and stop"
    text "    --network-name=XXX: Override the default network with a custom name"
    text "    --logs: View the logs from the Nginx proxy container"
    text "    --logs-f: View and follow the logs from the Nginx proxy container"
    text "    --domains: Show the domains that the Nginx proxy will respond to"
    text "    --networks: Show the list of networks that the Nginx proxy is operating on"

    ddt_app_error "Missing command, choose from one of the above commands"
}

function print_running_containers ()
{
    text blu Running containers:
    docker ps
}

function start_proxy ()
{
    if [ -z "$1" ]; then ddt_app_error "You must pass the name of the proxy docker image as the first parameter"; fi
    if [ -z "$2" ]; then ddt_app_error "You must pass the name of the network to run the proxy on as the second parameter"; fi

    network=$2

    # Create the network to bind all the containers onto
    docker_create_network ${network}

    # Run the proxy container
    container_id=$(docker_running_id $1)

    if [[ ! -z "${container_id}" ]]; then
        stop_proxy $1 ${container_id}
    fi

    text "${blu}Starting the nginx proxy container:${end} $1..."

    docker container prune -f

    if [ ! -z "$(docker container ls | grep ${name})" ]; then
        # first, remove the container that was previously built, cause otherwise it'll crash with "The container name /ddt-proxy" is already in use by container "xxxx" and this stops that
        text "Deleting container: \c"
        docker container rm ${name} 2>&1
        docker rm ${name} 2>&1
    fi

    container_id=$( \
        docker run -d --restart always \
        --network ${network} \
        --name ${name} \
        -p 80:80 \
        -p 443:443 \
        -v /var/run/docker.sock:/tmp/docker.sock:ro \
        -v ${DIR}/proxy-config/global.conf:/etc/nginx/conf.d/global.conf \
        -v ${DIR}/proxy-config/nginx-proxy.conf:/etc/nginx/proxy.conf \
        $1 \
    )
    text "Running '${name}', container id: ${container_id}"

    if [ -z "${container_id}" ]; then
        textbox red wht "The container ${name} did not start correctly"
        ddt_app_error "Exiting..."
    fi
}

function stop_proxy ()
{
    if [ -z "$1" ]; then ddt_app_error "You must pass the docker image as the first parameter"; fi
    if [ -z "$2" ]; then ddt_app_error "You must pass the container id as the second parameter in order to stop it"; fi

    text "${blu}Stopping the nginx proxy container:${end} $1..."

    docker kill $2 &>/dev/null
    docker rm -f $2 &>/dev/null

    # we don't delete the network since there is no real reason to want to do this
    # just leave it and reuse it when necessary
}

function get_networks ()
{
    networks=$(docker_container_networks ${name})

    if [ "$1" == "no-pretty" ]; then
        echo ${networks}
    else
        for n in ${networks}; do
            text "${blu}Network${end}: ${n}"
        done
    fi
}

# We search and process this option first, because we need it before all others (it doesn't really hurt performance)
for i in "${@:1}"; do
    case $i in
        --network-name=*)
            network_name=${i#*=}
        ;;
    esac
done

for i in "${@:1}"; do
    case $i in
        --networks|--networks=*)
            option=${i#*=}

            get_networks ${option}
        ;;

        --start)
            start_proxy ${docker_image} ${network_name}

            print_running_containers
            ddt-proxy --domains
        ;;

        --stop)
            container_id=$(docker_running_id ${name})

            if [ ! -z "${container_id}" ]; then
                stop_proxy ${docker_image} ${name}
            else
                textbox yel blk Status: Already stopped
            fi

            print_running_containers
        ;;

        --restart)
            ddt-proxy --stop
            ddt-proxy --start --network-name=${network_name}
        ;;

        --logs)
            container_id=$(docker_running_id ${docker_image})

            if [ -z "${container_id}" ]; then
                textbox red wht "The nginx proxy (${docker_image}) is not running, cannot execute request"
                ddt_app_error "Exiting..."
            fi

            docker logs ${container_id}
        ;;

        --logs-f)
            container_id=$(docker_running_id ${docker_image})

            if [ -z "${container_id}" ]; then
                textbox red wht "The nginx proxy (${docker_image}) is not running, cannot execute request"
                ddt_app_error "Exiting..."
            fi

            docker logs -f ${container_id}
        ;;

        --domains)
            text blu Domains that are registered in the nginx proxy:
            container_id=$(docker_running_id ${docker_image})

            if [ -z "${container_id}" ]; then
                textbox red wht "The nginx proxy (${docker_image}) is not running, cannot execute request"
                ddt_app_error "Exiting..."
            fi

            get_networks ${option}

            container_list=$(docker exec -it ${container_id} cat /etc/nginx/conf.d/default.conf | grep "upstream" | awk '{ print $2 }')

            mapping_list=(" Container ID'|'Virtual Host'|'Path*")
            for name in ${container_list}; do
                   domain=$(docker inspect ${name} -f '{{range .Config.Env}}{{println .}}{{end}}' | grep VIRTUAL_HOST)
                   domain=$([ ! -z ${domain} ] && echo ${domain} | sed "s/VIRTUAL_HOST=//g")

                   path=$(docker inspect ${name} -f '{{range .Config.Env}}{{println .}}{{end}}' | grep VIRTUAL_PATH)
                   path=$([ ! -z ${path} ] && echo ${path} | sed "s/VIRTUAL_PATH=//g")

                   port=$(docker inspect ${name} -f '{{range .Config.Env}}{{println .}}{{end}}' | grep VIRTUAL_PORT)
                   port=$([ ! -z ${port} ] && echo ":${port}" | sed "s/VIRTUAL_PORT=//g")

                   mapping_list+=("${name}'|'${domain}${port}'|'${path}*")
            done
            echo "${mapping_list[@]}" | tr '*' '\n' | column -t -s"'"
        ;;

        --config)
            container_id=$(docker_running_id ${docker_image})

            docker exec -it ${container_id} cat /etc/nginx/conf.d/default.conf
        ;;

        --help)
            help
        ;;
    esac
done

if [ $# -eq 0 ]; then
    help
fi
